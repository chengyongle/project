### 基于Gin+Gorm+Redis+RabbitMQ 秒杀系统API



#### 开发工具

goland2021.1.3

#### 开发环境

| golang | Mysql | redis | RabbitMQ |
| ------ | ----- | ----- | -------- |
| 1.16.5 | 5.7   | 3.2.1 | 3.9.5    |

#### 项目介绍

本系统是使用GO语言的Gin框架开发的高并发抢购秒杀系统，除了实现基本的后台（添加商品，订单等），前台（登录、查看商品列表、秒杀）等API，项目中还针对高并发情况实现了系统降级，限流，负载均衡。

本项目只关注于后端API开发，前端页面仅使用Gin框架模板简单设计。

#### 秒杀优化方向

将请求尽量拦截在系统上游：通过cookie验证、ip限流、令牌桶一系列限流方法及rabbitmq消息队列，多级缓冲保护，最大化减少对数据库的访问。防止请求都压到后端数据层，数据读写锁冲突严重，请求都超时。

#### 实现技术点

- ‌分布式权限验证和数量控制，降低系统耦合性和服务器压力
- 一致性哈希算法分流，自定义接口反向代理实现负载均衡‌
- redis+lua脚本实现ip限流，防止同一用户多次访问
- 使用GO自定义API加互斥锁代替redis实现数量控制,防止超卖
- ‌rabbitmq消息队列异步处理订单，排队写入，防止暴库，降低数据库压力
- 用redis实现令牌桶，限制流量控制速率



#### 测试工具

postman，wrk

压测效果：开启80个线程保持2000个压测30s，单机QPS在3500左右（测试机器：两台阿里云1核2G服务器）

#### 说明

##### 解决超卖

采用GO提供API的方式来代替redis来实现数量控制。

当流量非常大的情况下redis 和redis 集群会存在横行扩展的瓶颈，因为redis集群中key如果是一个的话，其实在集群内部访问的是同一台机器，在这种情况下当QPS超过一定程度项目就会出现瓶颈。如果要满足横向扩展就使用类似哨兵模式搭建集群，这样实现起来太复杂，成本也高；GO提供的单机接口能力可以达到 30WQPS（加互斥锁，没优化机器的情况下，测试机器：12核12G阿里云服务器）已经非常可观。

​																																						  ————来自网络

##### LUA脚本

使用redis+lua脚本代替redis分布式锁

- 可以在LUA脚本中封装若干操作，如果有多条Redis指令，封装好之后只需向Redis一次性发送所有参数即可获得结果
- Redis可以保证Lua脚本运行期间不会有其他命令插入执行，提供像数据库事务一样的原子性
- Redis会根据脚本的SHA值缓存脚本，已经缓存过的脚本不需要再次传输Lua代码，减少了通信成本，此外在自己代码中改变Lua脚本，执行时Redis必定也会使用最新的代码。



本项目是学习了github开源项目和慕课网视频之后的个人理解和知识汇总，仅用于记录自己的学习成果。
项目中一些冗余的技术实现仅是为了让自己熟悉技术的应用，并不代表这是最优的方式。

学习链接：

https://github.com/CodePrometheus/HelloGin

https://coding.imooc.com/class/347.html
